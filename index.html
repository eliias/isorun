<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  File: README
  
    &mdash; Documentation by YARD 0.9.28
  
</title>

  <link rel="stylesheet" href="css/style.css" type="text/css" />

  <link rel="stylesheet" href="css/common.css" type="text/css" />

<script type="text/javascript">
  pathId = "README";
  relpath = '';
</script>


  <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="js/app.js"></script>


  </head>
  <body>
    <div class="nav_wrap">
      <iframe id="nav" src="class_list.html?1"></iframe>
      <div id="resizer"></div>
    </div>

    <div id="main" tabindex="-1">
      <div id="header">
        <div id="menu">
  
    <a href="_index.html">Index</a> &raquo; 
    <span class="title">File: README</span>
  
</div>

        <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="class_list.html">

        <svg width="24" height="24">
          <rect x="0" y="4" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="12" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="20" width="24" height="4" rx="1" ry="1"></rect>
        </svg>
    </a>
  
</div>
        <div class="clear"></div>
      </div>

      <div id="content"><div id='filecontents'><p align="center">
  <img alt="isorun" src="./docs/assets/logo.png" width="200" />
</p>

<hr>

<blockquote>
<p>Run JavaScript applications in your Rails application.</p>
</blockquote>

<h2 id="features">Features</h2>

<ul>
<li>Import JavaScript functions, objects, or just values and use them in Ruby</li>
<li>An EMCAScript like Ruby DSL to load modules and import items</li>
<li>Automatically converts arguments and return values</li>
<li>Send messages between <em>JavaScript</em>&lt;-&gt;<em>Ruby</em> (allows to intercept network requests and avoid network round-trips for e.g. API calls)</li>
<li>Automatically reload modules when updated in development</li>
<li>Automatically extracts state (Apollo) and hydrates client-side </li>
<li>Supports server-side rendering of multiple apps on a single page</li>
<li>Examples for <a href="./examples/rails-react-app">React</a>, <a href="./examples/rails-vue-app">Vue</a>, <a href="./examples/rails-d3-app">D3</a> and a <a href="./examples/rails-multi-app">multi-app</a> setup</li>
</ul>

<h2 id="how-to">How to</h2>

<h3 id="plain-javascript">Plain JavaScript</h3>

<pre class="code js"><code class="js">// module.js
export function say(word) {
  return word;  
}
</code></pre>

<pre class="code ruby"><code class="ruby"><span class='id identifier rubyid_context'>context</span> <span class='op'>=</span> <span class='const'><span class='object_link'><a href="Isorun.html" title="Isorun (module)">Isorun</a></span></span><span class='op'>::</span><span class='const'><span class='object_link'><a href="Isorun/Context.html" title="Isorun::Context (class)">Context</a></span></span><span class='period'>.</span><span class='id identifier rubyid_new'>new</span>

<span class='comment'># import `export function say` from module 
</span><span class='id identifier rubyid_say'>say</span> <span class='op'>=</span> <span class='id identifier rubyid_context'>context</span><span class='period'>.</span><span class='id identifier rubyid_import'>import</span><span class='lparen'>(</span><span class='symbol'>:say</span><span class='rparen'>)</span><span class='period'>.</span><span class='id identifier rubyid_from'>from</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>./module.js</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span>
<span class='id identifier rubyid_say'>say</span><span class='period'>.</span><span class='id identifier rubyid_call'>call</span><span class='lparen'>(</span><span class='tstring'><span class='tstring_beg'>&quot;</span><span class='tstring_content'>Hello!</span><span class='tstring_end'>&quot;</span></span><span class='rparen'>)</span> <span class='comment'># &quot;Hello!&quot;
</span></code></pre>

<h3 id="simple-react-app">Simple React app</h3>

<pre class="code bash"><code class="bash">rails new myproject --javascript esbuild
cd myproject
</code></pre>

<pre class="code js"><code class="js">// package.json
{
  &quot;scripts&quot;: {
    &quot;build&quot;: &quot;esbuild app/javascript/app.jsx --bundle --sourcemap --outdir=app/assets/builds --public-path=assets&quot;,
    &quot;build-server&quot;: &quot;esbuild app/javascript/app-server.jsx --bundle --sourcemap --outdir=app/assets/builds --public-path=assets --format=esm&quot;
  }
}
</code></pre>

<pre class="code bash"><code class="bash"># Procfile.dev
web: bin/rails server -p 3000
js: yarn build --watch
ssr: yarn build-server --watch
</code></pre>

<pre class="code ruby"><code class="ruby"><span class='comment'># config/initializers/isorun.rb
</span><span class='const'><span class='object_link'><a href="Isorun.html" title="Isorun (module)">Isorun</a></span></span><span class='period'>.</span><span class='id identifier rubyid_configure'><span class='object_link'><a href="Isorun.html#configure-class_method" title="Isorun.configure (method)">configure</a></span></span> <span class='kw'>do</span>
  <span class='comment'># â€¦configure isorun
</span><span class='kw'>end</span>
</code></pre>

<pre class="code jsx"><code class="jsx">// app/javascript/my_app.jsx
import * as React from &quot;react&quot;;
import {hydrateRoot} from &quot;react-dom/client&quot;;

import {App} from &quot;./my_app/App.jsx&quot;;

const container = document.querySelector(&#39;#my_app&#39;);
hydrateRoot(container, &lt;App/&gt;);

</code></pre>

<pre class="code jsx"><code class="jsx">// app/javascript/my_app-server.jsx
import * as React from &quot;react&quot;;
import * as Server from &quot;react-dom/server&quot;;

import {App} from &quot;./my_app/App.jsx&quot;;

export default async function() {
  return Server.renderToString(&lt;App/&gt;);
}
</code></pre>

<pre class="code erb"><code class="erb">&lt;!--my_view.html.erb--&gt;
&lt;%= isorun_app(&quot;my_app&quot;) %&gt;
</code></pre>

<h2 id="ruby-and-platform-support">Ruby and platform support</h2>

<p>Ruby versions:</p>

<ul>
<li><code>2.7</code></li>
<li><code>3.0</code></li>
<li><code>3.1</code>.</li>
</ul>

<p>Platforms and architectures:</p>

<ul>
<li><code>x86_64-linux</code></li>
<li><code>x86_64-apple</code></li>
<li><code>arm64-apple</code> </li>
</ul>

<h2 id="demo">Demo</h2>

<p>You can also check out this demo video on YouTube. It shows how you can utilize
<em>isorun</em> to render SVGs with Ruby on the server, utilizing JavaScript and the
D3 library.</p>

<p><a href="https://www.youtube.com/watch?v=EPHX4po4X4g"><img src="./docs/assets/how-to-use-d3-in-ruby.png" alt="How to use d3 in Ruby"></a></p>

<h2 id="why-server-side-rendering-ssr">Why server-side rendering (SSR)?</h2>

<p>The fastest way to deliver an application to the user is streaming HTML directly
to the browser. The slowest way to deliver an application, is downloading a
JavaScript file first, parse and execute it on the client side.</p>

<p>Server-side rendering is taking advantage of the fact that we can render a
JavaScript application directly on the server, and stream the resulting HTML
directly to the browser.
Then we fetch the JavaScript file and eventually the application will
(re-)hydrate the already rendered user interface.</p>

<p>You can take this concept even further and make your application work without
JavaScript at all, but still use React or Vue (or any other view-controller
library) to define your user interface.</p>

<p>Read
more: <a href="https://jakearchibald.com/2017/netflix-and-react/">Netflix functions without client-side React, and it&#39;s a good thing</a>.</p>

<p>Server-side rendering has a few challenges:</p>

<ol>
<li>You need something that can compile and run JavaScript</li>
<li>You need to be able to integrate the app with your preferred framework</li>
<li>You need to deal with the reality of frontend clients making network requests and managing state</li>
</ol>

<p><strong>isorun</strong> aims to make it as simple as possible to integrate a
JavaScript application into your server-side development and deployment
workflow, without changing the development workflow for frontend engineers.</p>

<p>This gem provides a helper that can render a JavaScript application directly in
your Ruby process, embedding Google&#39;s <em>v8</em> library via <a href="https://crates.io/crates/deno_core"><em>deno_core</em></a>.
You can think of it as running a headless JavaScript browser directly in your
Ruby process (threads). Using <em>v8</em> allows us to completely separate the
execution environments between individual renders and therefore prevent any
potential <a href="https://vuejs.org/guide/scaling-up/ssr.html#cross-request-state-pollution">Cross-Request State Pollution</a>.
It is essentiallly the same as opening many tabs in one browser.</p>

<h2 id="why-ssr-for-ruby-on-rails">Why SSR for Ruby (on Rails)?</h2>

<p>I personally enjoy and use <em>Ruby on Rails</em> a lot, but I like to use some
Vue and React for frontend work. The integration of frontend and backend always
felt a bit off, and I wanted something that &quot;just works&quot; for most of my use
cases.</p>

<p>One goal of <strong>isorun</strong> is that server-side rendering should feel naturally in
Ruby and Rails. A simple tag helper should be enough to render, deliver, and
hydrate your complex JavaScript application. And if we want to do something
nice with visualization libraries, it should be possible to run any JavaScript
program and return the result to the user without spinning up a separate
service.</p>

<h3 id="alternatives">Alternatives</h3>

<h4 id="no-javascript">&quot;No&quot; JavaScript</h4>

<p>If you want to go all-in on the server side, I highly recommend taking a look at
<a href="https://hotwired.dev/">HTML over the Wire</a>, and <a href="https://docs.stimulusreflex.com/">StimulusReflex</a>.</p>

<h4 id="run-a-node-js-deno-or-bun-service">Run a Node.js, deno, or  bun service</h4>

<p><strong>isorun</strong> does SSR a bit different from how you would do it in a regular
Node.js service. In addition to being able to render the application, it also
supports more powerful features like network intercepts. This means, that you
can directly call into the Ruby process from the JavaScript application and
e.g. fetch data from the database. This is helpful for applications that
utilize APIs to fetch their data.
Even when server-side rendered, these applications issue network requests
against the production API endpoints to get access to data. In a lot of cases,
we can accelerate this process by forwarding the network requests directly to
the target controller/action in Rails.Instead of fetching </p>

<p><strong>Example</strong> A React applications queries a Rails GraphQL API</p>

<p>We can override the HttpLink <code>fetch</code> method and utilize the <code>@isorun/rails</code>
package to send the HTTP request for the GraphQL API directly to the Ruby
process, instead of sending it over the network.</p>

<pre class="code js"><code class="js">import {apollo} from &quot;@isorun/rails&quot;;

import {App} from &quot;../my_app/App.jsx&quot;;

const apolloClient = new ApolloClient({
  ssrMode: true,
  cache: new InMemoryCache(),
  link: new HttpLink({
    uri: &#39;http://localhost:3000/graphql&#39;,
    fetch: apollo.fetch
  })
});
</code></pre>

<pre class="code ruby"><code class="ruby"><span class='const'><span class='object_link'><a href="Isorun.html" title="Isorun (module)">Isorun</a></span></span><span class='period'>.</span><span class='id identifier rubyid_configure'><span class='object_link'><a href="Isorun.html#configure-class_method" title="Isorun.configure (method)">configure</a></span></span> <span class='kw'>do</span>
  <span class='id identifier rubyid_receiver'>receiver</span> <span class='kw'>do</span> <span class='op'>|</span><span class='id identifier rubyid_request'>request</span><span class='op'>|</span>
    <span class='id identifier rubyid_query'>query</span><span class='comma'>,</span> <span class='id identifier rubyid_variables'>variables</span><span class='comma'>,</span> <span class='id identifier rubyid_context'>context</span><span class='comma'>,</span> <span class='id identifier rubyid_operation_name'>operation_name</span> <span class='op'>=</span> <span class='id identifier rubyid_parse'>parse</span><span class='lparen'>(</span><span class='id identifier rubyid_request'>request</span><span class='rparen'>)</span>

    <span class='const'>RailsAppSchema</span><span class='period'>.</span><span class='id identifier rubyid_execute'>execute</span><span class='lparen'>(</span>
      <span class='id identifier rubyid_query'>query</span><span class='comma'>,</span>
      <span class='label'>variables:</span> <span class='id identifier rubyid_variables'>variables</span><span class='comma'>,</span>
      <span class='label'>context:</span> <span class='id identifier rubyid_context'>context</span><span class='comma'>,</span>
      <span class='label'>operation_name:</span> <span class='id identifier rubyid_operation_name'>operation_name</span>
    <span class='rparen'>)</span>
  <span class='kw'>end</span>
<span class='kw'>end</span>
</code></pre>

<h2 id="installation">Installation</h2>

<p>Install the gem and add to the application&#39;s Gemfile by executing:</p>

<pre class="code ruby"><code class="ruby">$ bundle add isorun
</code></pre>

<p>If bundler is not being used to manage dependencies, install the gem by
executing:</p>

<pre class="code ruby"><code class="ruby">$ gem install isorun
</code></pre>

<h2 id="development">Development</h2>

<p>After checking out the repo, run <code>bin/setup</code> to install dependencies. Then, run
<code>rake spec</code> to run the tests. You can also run <code>bin/console</code> for an interactive
prompt that will allow you to experiment.</p>

<p>To install this gem onto your local machine, run <code>bundle exec rake install</code>. To
release a new version, update the version number in <code>version.rb</code>, and then run
<code>bundle exec rake release</code>, which will create a git tag for the version, push
git commits and the created tag, and push the <code>.gem</code> file to
<a href="https://rubygems.org">rubygems.org</a>.</p>

<h2 id="contributing">Contributing</h2>

<p>Bug reports and pull requests are welcome on GitHub at
<a href="https://github.com/eliias/isorun">https://github.com/eliias/isorun</a>.</p>

<h2 id="license">License</h2>

<p>The gem is available as open source under the terms of the
<a href="https://opensource.org/licenses/MIT">MIT License</a>.</p>
</div></div>

      <div id="footer">
  Generated on Sat Dec 31 16:11:01 2022 by
  <a href="https://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.9.28 (ruby-3.0.5).
</div>

    </div>
  </body>
</html>