<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>
  File: README
  
    &mdash; Documentation by YARD 0.9.28
  
</title>

  <link rel="stylesheet" href="css/style.css" type="text/css" />

  <link rel="stylesheet" href="css/common.css" type="text/css" />

<script type="text/javascript">
  pathId = "README";
  relpath = '';
</script>


  <script type="text/javascript" charset="utf-8" src="js/jquery.js"></script>

  <script type="text/javascript" charset="utf-8" src="js/app.js"></script>


  </head>
  <body>
    <div class="nav_wrap">
      <iframe id="nav" src="file_list.html?1"></iframe>
      <div id="resizer"></div>
    </div>

    <div id="main" tabindex="-1">
      <div id="header">
        <div id="menu">
  
    <a href="_index.html">Index</a> &raquo; 
    <span class="title">File: README</span>
  
</div>

        <div id="search">
  
    <a class="full_list_link" id="class_list_link"
        href="class_list.html">

        <svg width="24" height="24">
          <rect x="0" y="4" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="12" width="24" height="4" rx="1" ry="1"></rect>
          <rect x="0" y="20" width="24" height="4" rx="1" ry="1"></rect>
        </svg>
    </a>
  
</div>
        <div class="clear"></div>
      </div>

      <div id="content"><div id='filecontents'><p align="center">
  <img alt="isorun" src="./docs/assets/logo.png" width="200" />
</p>

<hr>

<blockquote>
<p>A JavaScript render target for Ruby (on Rails)</p>
</blockquote>

<p><strong>⚠ ️Attention:</strong> Don&#39;t use this for anything but experiments. There are better ways to embed V8
in your application. Check out <a href="https://github.com/rubyjs/mini_racer">miniracer</a>.</p>

<h2 id="server-side-rendering">Server-side rendering</h2>

<p>The slowest way to deliver a user interface, is delivering a JavaScript file
to the client, and then execute it to build up a DOM tree.</p>

<p>The fastest way is serving an HTML page with embedded styles, and doing so as a
stream of contents to the client. Eventually the application will (re-)hydrate
the already rendered user interface as soon as the downloaded JavaScript code
is executed.</p>

<p>You can take this concept even further and make your application work without
JavaScript at all, but still use React or Vue (or any other view-controller
library) to define your user interface.</p>

<p>Read
more: <a href="https://jakearchibald.com/2017/netflix-and-react/">Netflix functions without client-side React, and it&#39;s a good thing</a>.</p>

<p>Server-side rendering has a few challenges:</p>

<ol>
<li>You need something that can compile and run JavaScript</li>
<li>You need to be able to integrate it into your language and framework</li>
<li>You need to deal with the reality of frontend clients making network requests</li>
</ol>

<p><strong>isorun</strong> aims to make it as simple as possible to integrate any existing
JavaScript application into your server-side development and deployment
workflow.</p>

<p>This gem provides a helper that can render a JavaScript application on the
server by embedding Google&#39;s v8 library directly in your server process(es).
You can think of it as running a headless browser in your Ruby process.
<strong>isorun</strong> utilizes V8 Isolates via the Rust crates: v8 and deno_core. This
allows us to completely separate applications from each other and to prevent
any <a href="https://vuejs.org/guide/scaling-up/ssr.html#cross-request-state-pollution">Cross-Request State Pollution</a>.
It is like having multiple tabs open in your browser.</p>

<h2 id="why-ssr-for-ruby-on-rails">Why SSR for Ruby (on Rails)?</h2>

<p>I use <em>Ruby on Rails</em> a lot for my own projects, and I also use Vue and React.
One of my goals for <strong>isorun</strong>, is that server-side rendering should feel
naturally in Rails. A simple tag helper should be enough to render, deliver,
and hydrate your complex JavaScript application.</p>

<p>I also like the relatively new concept of
<a href="https://hotwired.dev/">HTML over the Wire</a>, but I can&#39;t and don&#39;t want to use
it for everything.</p>

<h2 id="why-not-just-spinning-up-a-node-js-deno-bun-service">Why not just spinning up a Node.js/deno/bun service?</h2>

<p><strong>isorun</strong> does SSR a bit different than you would do it in a regular Node.js
service. It allows you to intercept network calls and can provide <em>state</em> to
the render context. This allows you to take a shortcut when rendering on the
server. Data is no longer fetched over the network, but provided almost directly
to the application.</p>

<p>I have built and operated Node.js SSR services, but it has always been super
tedious to set up a dedicated service, just for server side rendering.
Especially when your backend isn&#39;t written in JavaScript. A SSR service is just
another single point of failure, and it literally has to process every request.
It adds significantly to your infrastructure cost, migrating from an existing
app is hard, and there is also operational overhead.</p>

<p>Most importantly, it adds complexity, and that is something I try to avoid in
projects I am working on.</p>

<h2 id="installation">Installation</h2>

<p>Install the gem and add to the application&#39;s Gemfile by executing:</p>

<pre class="code ruby"><code class="ruby">$ bundle add isorun
</code></pre>

<p>If bundler is not being used to manage dependencies, install the gem by
executing:</p>

<pre class="code ruby"><code class="ruby">$ gem install isorun
</code></pre>

<h2 id="usage">Usage</h2>

<pre class="code bash"><code class="bash">rails new myproject --javascript esbuild
</code></pre>

<pre class="code jsx"><code class="jsx">// app/javascript/my_app.jsx
import * as React from &quot;react&quot;;
import {hydrateRoot} from &quot;react-dom/client&quot;;

import {App} from &quot;./my_app/App.jsx&quot;;

const container = document.querySelector(&#39;#my_app&#39;);
hydrateRoot(container, &lt;App/&gt;);

</code></pre>

<pre class="code jsx"><code class="jsx">// app/javascript/my_app-server.jsx
import * as React from &quot;react&quot;;
import * as Server from &quot;react-dom/server&quot;;

import {App} from &quot;./my_app/App.jsx&quot;;

export function render() {
  return Promise.resolve(Server.renderToString(&lt;App/&gt;));
}
</code></pre>

<pre class="code erb"><code class="erb">&lt;!--my_view.html.erb--&gt;
&lt;%= isorun_app_tag(&quot;my_app&quot;) %&gt;
</code></pre>

<pre class="code json"><code class="json">{
  &quot;scripts&quot;: {
    &quot;build&quot;: &quot;esbuild app/javascript/*.* --bundle --sourcemap --outdir=app/assets/builds --public-path=assets --format=esm&quot;
  }
}
</code></pre>

<h2 id="development">Development</h2>

<p>After checking out the repo, run <code>bin/setup</code> to install dependencies. Then, run
<code>rake spec</code> to run the tests. You can also run <code>bin/console</code> for an interactive
prompt that will allow you to experiment.</p>

<p>To install this gem onto your local machine, run <code>bundle exec rake install</code>. To
release a new version, update the version number in <code>version.rb</code>, and then run
<code>bundle exec rake release</code>, which will create a git tag for the version, push
git commits and the created tag, and push the <code>.gem</code> file to
<a href="https://rubygems.org">rubygems.org</a>.</p>

<h2 id="contributing">Contributing</h2>

<p>Bug reports and pull requests are welcome on GitHub at
<a href="https://github.com/eliias/isorun">https://github.com/eliias/isorun</a>.</p>

<h2 id="license">License</h2>

<p>The gem is available as open source under the terms of the
<a href="https://opensource.org/licenses/MIT">MIT License</a>.</p>
</div></div>

      <div id="footer">
  Generated on Thu Nov 17 10:34:14 2022 by
  <a href="https://yardoc.org" title="Yay! A Ruby Documentation Tool" target="_parent">yard</a>
  0.9.28 (ruby-3.0.4).
</div>

    </div>
  </body>
</html>